# epoll

select 模式存在的三个问题
1. 能监听的fd最大不超过1024
2. 每次select都需要把所有要监听的fd都拷贝到内核空间
3. 每次都要遍历所有的fd来判断就绪状态

poll模式的问题
1. poll利用链表解决了select中监听fd上限的问题，但依然要遍历所有fd，如果监听较多，性能会下降

epoll模式中如何解决这些问题的？
1. 基于epoll实例中红黑树保存要监听的fd,理论上无上限，而且增删改查效率都非常高，性能不会随监听的fd数量增多而下降
2. 每个fd只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝fd到内核空间
3. 内核会将就绪的fd直接拷贝到用户空间的指定位置，用户进程无需遍历所有fd就能知道就绪的fd是谁



# io多路复用-事件通知机制

当fd有数据可读时，我们调用epoll_wait就可以得到通知。但是事件通知的模式有两种：
1. LevelTriggered:简称LT。当fd有数据 可读时，会我重复通知多次，直至数据处理完成。是epoll的默认模式。
2. EdgeTriggered:简称ET。当fd有数据可读时。只会被通知一次。不管数据是否处理完成。

1. 假设一个客户端socket对应的fd已经注册到了epoll实例中
2. 客户端socket发送了2kb的数据
3. 服务端调用epoll_wait，得到通知说fd就绪
4. 服务端从fd读取了1kb数据
5. 回到步骤3

结论：

* ET模式避免LT模式可能出现的惊群现象
* ET模式最好结合非阻塞IO读取FD数据，相比LT会复杂一些
