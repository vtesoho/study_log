# 二叉树

## 二叉树的先序、中序、后序遍历

先序：任何子树的处理顺序都是，先头节点，在左子树，然后右子树

中序：任何子树的处理顺序都是，先左子树，再头节点，然后右子树

后序：任何子树的处理顺序都是，先左子树，在右子树，然后头节点

## 递归序

二叉树的递归遍历，每个节点都会经过3次

先中后序遍历，就是在递归序中第一，第二，第三次出现这个数的顺序

第一次到达一个节点就打印就是先序，第二次打印即中序，第三次即后序


## 非递归方式实现二叉树的先序、中序、后序遍历

1. 任何递归函数都可以改成非递归 
2. 自己设计压栈来实现



先序 
 
1. 弹出打印
2. 如果有右孩子，就压入右
3. 如果有左孩子，就压入左


中序
1. 
2. 
3. 


后序

准备二个栈
弹出压入另一个辅助栈
1. 先压入头
2. 如果有左孩子，压入左
3. 如果有右孩子，圧入右
4. 在依次弹出辅助栈









# 宽度优先遍历

准备一个队列
1. 先压入头节点
2. 循环遍历，直到队列不为空 
2. 弹出一个节点并打印
3. 左孩子不为空压入左孩子
4. 右孩子不为空压入右孩子


# 宽度优先遍历，找到最宽的那一层

一个变量A记录当前正在统计那一层
一个变量B记录当前层的宽度
一个max记录最大宽度
准备一个map,记录当前节点是那一层
准备一个队列
1. 先压入头节点
2. 循环遍历，直到队列不为空 
获取当前节点是在那一层
2. 弹出一个节点并打印
3. 左孩子不为空压入左孩子（在map里记录是那一层）
4. 右孩子不为空压入右孩子（在map里记录是那一层）
if当前正在统计的层等于当前节点的层数{
    当前层的宽度加一
}else{
    不等于相当于是另一层的开始
    max = max(max,变量B)
    当前正的统计的那一层加一
    当前层最大宽度重层为一
}
因为最后一层相当于是只做了统计，但是没有和之前的max做对比。
所有在循环外，还要做一次变量判断max = max(max,变量B)

# 宽度优先遍历，找到最宽的那一层，不用map方式

一个变量A 记录当前层最右节点
一个变量B 记录下一层最右节点
一个变量C 当前层的节点数
一个变量max记录当前层节点数的值
一个队列L
首先push头节点
循环(L不为空){
    cur = 弹出节点
    if(cur左不为空){
        cur左孩子加上队列
        B = cur左孩子
    }
    if(cur右不为空){
        cur右孩子加上队列
        B = cur右孩子
    }
    C++
    if(cur == A){说明这一层已经结束，将开始新一层
        max = max(max,C)
        C = 0 //重质当前节点
        A = B
    }
}
return max







