## 归并排序

1. 递归方法
以数据的中心切割，左边的0-mid，右边的mid-结束，以递归调用，直到左边等于右边结束，然后合并，创建一个L+R大小的数组，左右二边不越界的情况下，左边小就添加进数组，左指针++，右边小就右边加入数组，右指针++，如果那边越界了，就把左边或是右边全部加入数组。

然后写回之前的数组中。


2. 非递归方法
对数据进行以2为底数的操作。操作完2*2，直到超出数据大小为止。



## 快速排序
1.0 版本
以arr[length-1]为基数，把这个数组变成左边比arr[length-1]小，右边比arr[length-1]大，然后在交换右边的第一个与arr[length-1]，在左右二边进行递归排序


2.0 版本
在1.0版本基础之上记录了有多少个值等于基数的


3.0 版本
在数组里面随机找出一个数为基数，左右二边的数就相当于是各种概率都有了，概率相加后的结果就是logn，所有时间复杂度就是logn


## 堆
以i为基数，向下取整
左: 2*i+1
右: 2*i+2
父: (i-1)/2

第二个文案
第0个位置不用
左：2*i  左移一位
右：2*i+1   左移一位与1
父：i/2  右移一位


大根堆
定义：每一棵子树的最大值，都是头节点的值


排序过程

1，把数据调整成大根堆
2. 把最大的和最后一位交换
3. heapify整个结构
4. 在做0和n-1位置的交换
5. 循环3-4步骤，直到heapsize == 0









