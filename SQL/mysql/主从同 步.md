# mysql主从同步


master到slave

首先是master的sql执行成功之后，会生成binlog，这时候是顺序写入，slave的 io/thread线程把binlog同步到relay log日志上去，这时候也是顺序写入。然后就是slave的sql thread线程执行relaylog，这时候就是多线程执行了。


有从服务器上通过show slave status查看具体参数。有几个参数比较重要

master_log_file: slave中的io线程正在读取的主服务器二进制日志文件的名称

read_master_log_post: 在当前的主服务器二进制日志中，slave中的io线程已经读取的位置

relay_log_file: sql线程当前正在读取和执行的中继日志文件的名称

relay_log_post: 在当前中继日志中，sql线程已经读取和执行的位置

relay_master_log_file: 由sql线程执行的包含多数近期事件的主服务器二进制日志文件的名称

slave_io_running: io线程是否被启动并成功的连接到主服务器上

slave_sql_running: sql线程是不靠谱好吃启动

seconds_behind_master: 从属服务器sql线程和从属服务器io线程之间的事件差距，单位为秒

在观察同步延迟的时候， 上述几个参数是比较重要的，其中有一个最最重要的参数需要引起注意，那就是seconds_behind_master,这个参数表示当前备库延迟了多长时间，那么这个值是如何计算的？

在进行主从复制的时候，需要注意以下几个关键的时刻

1. 主库A执行完一个事务，写入binlog，这个时刻为T1
2. 之后传给从库B，我们把从库B接受完这个binlog时刻记为T2
3. 备库B执行完成这个事务，我们把这个时刻记为T3

所谓的主从延迟就是同一个事务，在从库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。SBM在进行计算的时候也是按照这样的方式，每个事务的binlog中都有一个时间字段，用于记录主库写入的时间，从库取出当前正在执行事务的时间字段的值，计算它与当前系统时间的差值，得到SBM


















