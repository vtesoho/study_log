# mysql主从同步


master到slave

首先是master的sql执行成功之后，会生成binlog，这时候是顺序写入，slave的 io/thread线程把binlog同步到relay log日志上去，这时候也是顺序写入。然后就是slave的sql thread线程执行relaylog，这时候就是多线程执行了。


有从服务器上通过show slave status查看具体参数。有几个参数比较重要

master_log_file: slave中的io线程正在读取的主服务器二进制日志文件的名称

read_master_log_post: 在当前的主服务器二进制日志中，slave中的io线程已经读取的位置

relay_log_file: sql线程当前正在读取和执行的中继日志文件的名称

relay_log_post: 在当前中继日志中，sql线程已经读取和执行的位置

relay_master_log_file: 由sql线程执行的包含多数近期事件的主服务器二进制日志文件的名称

slave_io_running: io线程是否被启动并成功的连接到主服务器上

slave_sql_running: sql线程是不靠谱好吃启动

seconds_behind_master: 从属服务器sql线程和从属服务器io线程之间的事件差距，单位为秒

在观察同步延迟的时候， 上述几个参数是比较重要的，其中有一个最最重要的参数需要引起注意，那就是seconds_behind_master,这个参数表示当前备库延迟了多长时间，那么这个值是如何计算的？

在进行主从复制的时候，需要注意以下几个关键的时刻

1. 主库A执行完一个事务，写入binlog，这个时刻为T1
2. 之后传给从库B，我们把从库B接受完这个binlog时刻记为T2
3. 备库B执行完成这个事务，我们把这个时刻记为T3

所谓的主从延迟就是同一个事务，在从库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。SBM在进行计算的时候也是按照这样的方式，每个事务的binlog中都有一个时间字段，用于记录主库写入的时间，从库取出当前正在执行事务的时间字段的值，计算它与当前系统时间的差值，得到SBM








# 主从复制延迟产生的原因有哪些？

1. 在某些部署环境中，从库所在的机器性能要比主库所在的机器性能差。此时如果机器的资源不足的话就会影响从库同步的效率
2. 从库充当了读库，一般情况下主要写的压力在于主库，那么从库会提供一倍分读的压力，而如果从库的查询 压力过大的话，从库的查询 消耗了大量的cpu资源，那么必不可少的就是会影响同步的速度
3. 大事务执行，如果主库的一个事务执行了10分钟，而binlog的写入必须要等待事务完成之后，才会传入从库，那么此时开始执行的时候就已经延迟了10分钟
4. 主库的写操作是顺序写binlog，从库单线程去主库顺序读binlog，从库取到binlog之后在本地执行。mysql的主从复制都是单线程的操作，但是由于主库是顺序写，所以效率很高，而从库也是顺序读取主库日志，此时效率也是比较高的，但是当数据拉取回来之后变成了随机的操作，而不是顺序的，所有此时成本会提交
5. 从库在同步数据的同时，可能跟其它查询的线程发生锁抢占的情况，此时也会发生延迟
6. 当主库TPS并发非常高的时候，产生的DDL数量超过了一个线程所能承受的范围的时候，那么也可能带来延迟
7. 在进 行binlog日志传输的时候，如果网络带宽不是很好，那么网络延迟也可能造成数据同步延迟










