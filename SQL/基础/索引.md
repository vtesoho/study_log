## 索引

### 什么是索引？ 有什么用？
```
索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。
在数据库方面，查询一张表的时候有两种检索方式：
第一种方式：全有扫描
第二种方式：根据索引检索（效率很高）

索引为什么可以提高检索效率呢？
其实最根本的原理是缩小了扫描的范围

索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要数据库不断的维护，是有维护成本的，比如，表中的数据 经常被修改，这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。

select A表字段 from A表 where A表字段 = 'aaa';
当A表字段没有添加索引的时候,以上sql语句会进行全表扫描，扫描A表字段中的所有的值。
当A表字段添加索引的时候，以上sql语句根据索引扫描，快速定位。
```

### 怎么创建索引？怎么删除索引对象?
```
创建索引对象
create index 索引名 on 表名(字段名);
删除索引对象
drop index 索引名称 on 表名;

```

### 什么时候考虑给字段添加索引？（满足什么条件）
```
数据量庞大。
该字段很少的dml操作。（因为字段进行修改操作，索引也需要维护）
该字段经常出现在where子句中。（经常根据那个字段查询）
```

### 主键和具有unique约束的字段会自动添加索引。

### 怎么优化索引
```
比如一条语句
select A表字段 from A表 where A表字段 = '***';
要查看这条语句有没有用到索引
explain select A表字段 from A表 where A表字段 = '***';
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | products | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+

执行后能看到type这项是ALL，代表是全表扫描，rows扫描了4次

然后我们创建一个索引
create index products_code_index on products(code);

+----+-------------+----------+------------+------+---------------------+---------------------+---------+-------+------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys       | key                 | key_len | ref   | rows | filtered | Extra       |
+----+-------------+----------+------------+------+---------------------+---------------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | products | NULL       | ref  | products_code_index | products_code_index | 1023    | const |    1 |   100.00 | Using index |
+----+-------------+----------+------------+------+---------------------+---------------------+---------+-------+------+----------+-------------+

可以看到type变成ref，还可以看到用到了那个索引。


```


### 索引底层采用的数据结构是: B + Tree


### 索引的实现原理


### 索引的分类
```
单一索引：给单个字段添加索引
复合索引：给多个字段联合起来添加一个索引
主键索引：主键会自动添加索引
唯一索引：可以出现一个null
全文索引：通过模糊匹配查找到对应的行
```


### B+ 多路平衡搜索树

对比其它的树 avl,红黑树，B+树的目的是加快索引，减少层高，从而减少磁盘id

有如下特征
1. 叶子节点存储的是数据具体信息
2. 非叶子节点存储是索引信息
3. 叶子节点之间互相连接，方便查找



有两种类型的B+树

聚集索引B+树
按照主键构造的B+树，叶子节点中存放数据页，数据也是索引的一部分。

铺助索引B+树
非主键索引对应的B+树
叶子节点存储了主键信息



节占高度计算

key 索引 大约10byte   指针大小为6byte  假设一行数据 为1KB

非叶子节点 16K = 16kB / 16byte = 1024个

叶子节点  1024行数据 

结论：2层B+树 1024*16 = 16384

3层 B+树    1024*1024*16 = 16777216

4层 B+树    1024*1024*1024*16 = 170亿


一般都只会存在三层，有些公司一般是500W行要求分表


优化
1. 尽量使用短索引
2. 对于很长的字符串   可以对于这个字符串的前面部分创建索引，还可以使用全文索引
3. 索引不创建太多了，一般6个就行了
4. 尽量扩展索引 
5. 条件语句当中不要对索引进行列运算
6. 不要隐式转换





### 最左匹配原则 

前提：针对组合索引 

对于组合索引，从左到右依次匹配，遇到 > < between like 就会终止匹配

优化：
1. 在组合索引中，如果没有使用第一列索引，索引会失效


### 覆盖索引 

从辅助索引 B+树就能找到数据，而不需要通过聚集索引

如果搜索的所有列在索引中全部能找到，搜索条件就算不是最左，也会匹配到。




