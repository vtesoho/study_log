# Golang协程调度器原理与GMP设计思想

## ⽬标：掌握Golang协程调度器原理：为什么Go的协程的调度是很快的


### ⼀、Golang“调度器”由来


1.1 单进程时代的两个问题？
1.1.1 单⼀执⾏流程、计算机只能⼀个任务⼀个任务处理
1.1.2 进程阻塞所带来的的CPU浪费时间

1.2 多进程、多线程的问题？
1.2.1 设计变得复杂
1.2.1.1 进程/线程的数量越多，切换成本就越⼤，也就越浪费
1.2.1.2 多线程 随着 同步竞争(如 锁、竞争资源冲突等)


1.2.2 多进程、多线程的壁垒

1.2.2.1 ⾼内存占⽤
1.2.2.1.1 进程占⽤内存 虚拟内存4GB(32bit OS)
1.2.2.1.2 线程占⽤内存 约4MB

1.2.2.2 ⾼CPU调度消耗


1.3 协程(co-routine), 引发的问题？


1.3.1 N:1
1.3.1.1 ⽆法利⽤多个CPU
1.3.1.2 出现阻塞的瓶颈

1.3.2 1:1
1.3.2.1 跟多线程/多进程模型⽆异
1.3.2.2 切换协程成本代价昂贵

1.3.3 M:N
1.3.3.1 能够利⽤多核
1.3.3.2 过于依赖协程调度器的优化和算法




1.4 调度器的优化
1.4.1 Goroutine的优化
1.4.1.1 内存占⽤ ⼏KB ⼤量开辟
1.4.1.2 灵活调度 切换成本低

1.4.2 早期的Go的调度器
1.4.2.1 基本的全局Go队列和⽐较传统的
1.4.2.2 轮询利⽤多个thread去调度

1.4.3 弊端
1.4.3.1 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。
1.4.3.2 M转移G会造成延迟和额外的系统负载。
1.4.3.3 系统调⽤(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。




## ⼆、Goroutine调度器的GMP模型的设计思想


2.1 GMP模型的简介
2.1.1 GMP
2.1.1.1 G:goroutine 协程
2.1.1.2 P:processor 处理器
2.1.1.3 M:thread 内核线

2.1.2 全局队列
2.1.2.1 存放等待运⾏的G

2.1.3 P的本地队列
2.1.3.1 存放等待运⾏的G
2.1.3.2 数量限制 不超过256G
2.1.3.3 优先将新创建的G放在P的本地队列中，如果满了会放在全局队列中


2.1.4 P列表
2.1.4.1 程序启动时创建
2.1.4.2 最多有GOMAXPROCS个(可配置)

2.1.5 M列表
2.1.5.1当前操作系统分配到当前Go程序的内核线程数

2.1.6 P和M的数量

2.1.6.1 P的数量问题
2.1.6.1.1 环境变量$GOMAXPROCS
2.1.6.1.2 在程序中通过runtime.GOMAXPROCS() 来设置

2.1.6.2 M的数量问题
2.1.6.2.1 Go语⾔本身 是限定M的最⼤量是10000(忽略)
2.1.6.2.2 runtime/debug包中的SetMaxThreads函数来设置
2.1.6.2.3 有⼀个M阻塞，会创建⼀个新的M
2.1.6.2.4 如果有M空闲，那么就会回收或者睡眠



##  2.2 调度器的设计策略
复⽤线程 避免频繁的创建、销毁线程，⽽是对线程的复⽤。
work stealing机制
当本线程⽆可运⾏的G时，尝试
从其他线程绑定的P偷取G，⽽不
是销毁线程。
hand off机制
当本线程因为G进⾏系统调⽤阻
塞时，线程释放绑定的P，把P转
移给其他空闲的线程执⾏。
利⽤并⾏ GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运⾏。
抢占 在coroutine中要等待⼀个协程主动让出CPU才执⾏下⼀个协程，在Go
中，⼀个goroutine最多占⽤CPU 10ms，防⽌其他goroutine被饿死.
全局G队列 当M执⾏work stealing从其他P偷不到G时，它可以从全局G队列获取G。


## (3) “go func()” 经历了什么过程

