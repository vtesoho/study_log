# Golang协程调度器原理与GMP设计思想

## ⽬标：掌握Golang协程调度器原理：为什么Go的协程的调度是很快的


### ⼀、Golang“调度器”由来


1.1 单进程时代的两个问题？
1.1.1 单⼀执⾏流程、计算机只能⼀个任务⼀个任务处理
1.1.2 进程阻塞所带来的的CPU浪费时间

1.2 多进程、多线程的问题？
1.2.1 设计变得复杂
1.2.1.1 进程/线程的数量越多，切换成本就越⼤，也就越浪费
1.2.1.2 多线程 随着 同步竞争(如 锁、竞争资源冲突等)


1.2.2 多进程、多线程的壁垒

1.2.2.1 ⾼内存占⽤
1.2.2.1.1 进程占⽤内存 虚拟内存4GB(32bit OS)
1.2.2.1.2 线程占⽤内存 约4MB

1.2.2.2 ⾼CPU调度消耗


1.3 协程(co-routine), 引发的问题？


1.3.1 N:1
1.3.1.1 ⽆法利⽤多个CPU
1.3.1.2 出现阻塞的瓶颈

1.3.2 1:1
1.3.2.1 跟多线程/多进程模型⽆异
1.3.2.2 切换协程成本代价昂贵

1.3.3 M:N
1.3.3.1 能够利⽤多核
1.3.3.2 过于依赖协程调度器的优化和算法






