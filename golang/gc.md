# gc

go v1.3之前的标识清除法(mark and sweep)

1. 暂停程序业务逻辑，找出不可达的对象，和可达对象
2. 开始标记，找出它所有可达的对象，并做上标识
3. 标记完了之后，然后开始清除未标记的对象
4. 停止暂停，让程序继续跑。然后循环重复这个过程，直接process程序生命周期结束。


标记清除的方法缺点

1. SWT, stop the world，让程序暂停，程序出现卡顿
2. 标记需要扫描整个heap
3. 清除数据会产生heap碎片




go v1.5三色标记法

1. 只要是创建的对象，默认颜色都是白色
2. 每次GC回收开始，然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入灰色中
3. 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此对象放入黑色集合
4. 重复第三步，直到灰色中无任何对象
5. 回收所有的白色标记表的对象，也就是回收拉级


如果三色标识法不被STW保护

1. 一个白色对象被黑色对象引用
2. 灰色对象与这个白色对象之间的可达关系的遭到破坏

如果两个条件同时满足就会造成把有用的对象当成拉级回收




强三色不变式

强制性的不允许黑色对象引用白色对象




弱三色不变式

黑色对象可以引用白色对象

白色对象存在其它灰色对象对它的引用，或者可达它的链路上游存在灰色对象

在三色标记中如果满足强。弱之一，即可保证对象不丢失



# 屏障机制

## 插⼊屏障

### 对象被引⽤时 触发的机制
1. 具体操作: 在A对象引⽤B对象的时候，B对象被标记为灰⾊。(将B挂在A下游，B必须被标记为灰⾊)
2. 满⾜: 强三⾊不变式. (不存在⿊⾊对象引⽤⽩⾊对象的情况了， 因为⽩⾊会强制变成灰⾊)

```
//伪码
添加下游对象(当前下游对象slot, 新下游对象ptr) {
 //1
 标记灰⾊(新下游对象ptr)
 //2 
 当前下游对象slot = 新下游对象ptr
}
```

A.添加下游对象(nil, B) //A 之前没有下游， 新添加⼀个下游对象B， B被标记为灰⾊

A.添加下游对象(C, B) //A 将下游对象C 更换为B， B被标记为灰⾊

不⾜

结束时需要STW来重新扫描栈，⼤约需要10~100ms



# 删除屏障

## 对象被删除时 触发的机制
被删除的对象，如果⾃身为灰⾊或者⽩⾊，那么被标记为灰⾊。

满⾜: 弱三⾊不变式. (保护灰⾊对象到⽩⾊对象的路径不会断)


```
//伪码
添加下游对象(当前下游对象slot， 新下游对象ptr) {
 //1
 if (当前下游对象slot是灰⾊ || 当前下游对象slot是⽩⾊) {
 标记灰⾊(当前下游对象slot) //slot为被删除对象， 标记为灰⾊
 }
 //2
 当前下游对象slot = 新下游对象ptr
}
```


A.添加下游对象(B, nil) //A对象，删除B对象的引⽤。 B被A删除，被标记为灰(如果B之前为⽩)

A.添加下游对象(B, C) //A对象，更换下游B变成C。 B被A删除，被标记为灰(如果B之前为⽩)


回收精度低，

⼀个对象即使被删除了最后⼀个指向它的指针也依旧可以活过这⼀轮，在下⼀轮GC中被清理掉。



Go V1.8 混合写屏障机制

1、GC开始将栈上的对象全部扫描并标记为⿊⾊(之后不再进⾏第⼆次重复扫描，⽆需STW) 
2、GC期间，任何在栈上创建的新对象，均为⿊⾊。
3、被删除的对象标记为灰⾊。
4、被添加的对象标记为灰⾊。
满⾜: 变形的弱三⾊不变式. (结合了插⼊、删除写屏障两者的有点)